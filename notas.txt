Lazy load, suspense y paginación con React

-Muchas veces, al traer resultados de una API, sí son texto podría venir como:
  'esto%20es%20una%20prueba'. Esto se soluciona con el metodo decodeURI(texto) que 
  sustituye la parte no entendible por espacios.

Importar sin usar los puntos.
  -En la raiz del proyecto creamos el archivo jsconfig.json.
  -Ingresamos lo siguiente: {"compilerOptions": {"baseUrl": "src"}}.

Intersection observer:
  -Vamos a usar el intersection observer para renderizar (y hacer el fetching) de las
    tendencias que están al final de la página.
  -Para ello, no vamos a exportar el componente que teniamos creado, sino otro que 
    crearemos más abajo.
  -En este segundo tendremos un estado para definir sí el componente se mostrará o no,
    este estado lo cambiaremos dentro de la función del intersection observer.
  -El intersecion observer lo haremos completo dentro del useEffect.
  -Su función debe cambiar el estado.
  -Segun este estado, retornariamos el componente que teniamos antes o no, sí el estado
    esta en false (el elemento no está en pantalla) retornamos null.
  -El elemento que observará el intersection observer será el elemento que encapsula todo
    este segundo componente (con useRef), y dentro de este encapsulador es que validamos
    el estado.

Problema con este intersection observer:
  -Es posible que veamos que desde el inicio se carguen las tendencias.
  -Esto es porque al inicio, no hay gifs, entonces al puro inicio las tendencias estarán
    en la pantalla, aunque no se vean.
  -Esto lo podemos solucionar sí al contenedor de los gifs le colocamos un alto minimo 
    para que las tendencias no se vean.

Desconexiones del intersecion observer:
  -Como una vez cargado las tendencias no queremos seguir observando, despues de
    rederizadas usamos el metodo disconnect() del intersection observer.
  -El callback de los useEffect puede retornar una función para limpiar cosas como 
    desuscripciónes. En nuestro caso, dentro de esa función vamos a desconectarnos()
    de la misma manera.

Polyfill de intersection observer:
  -Hay navegadores que no soportan el Intersection observer. Para esto usaremos un 
    polyfill. Lo instalamos con npm install intersection-observer.
  -Despues del useEffect usamos Promise.resolve().
  -Como parametro, sí el tipo de IntersectionObserver es distinto de 'undefined' retornamos 
    IntersectionObserver, de lo contrario, hacemos un import dinamico del polyfill instalado (sin
    una const).
  -Esto retorna una promesa, entonces en su then, creamos el intersection observer y 
    hacemos el observe.
  -Como habran bloques a los que la const que tiene el intersection observer no llega,
    tenemos que declarar al inicio del componente esa variable, y que se pueda usar
    en el resto de bloques.